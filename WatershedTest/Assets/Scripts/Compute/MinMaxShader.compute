// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel NormalizedSampler
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float> Result;

Texture2D<float4> PassedInData;

RWStructuredBuffer<uint> MinMax;
groupshared uint max = 0;

uint fromx = 0;
uint fromy = 0;
uint tox = 0;
uint toy=0;

uint sampleRate = 100;
SamplerState _LinearClamp;

uint2 direction = uint2(0,0);
[numthreads(32,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID, uint3 gid : SV_GroupID )
{
    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
    //InterlockedMax(
    //in  R dest,
    // in  T value,
   // out T original_value
   
   // Access the texture!!!! 
   // Get Width and Height
   uint width = 0;
   uint height = 0;
   PassedInData.GetDimensions(width,height);

   
   float4 data = PassedInData.SampleLevel(_LinearClamp, 
   float2((float)fromx / (float)(width-1) , (float)fromy/(float)(height-1)) + 
   (float2( (float)(tox - fromx)/(float)(width-1), 
   (float)(toy - fromy)/ (float)(height-1) ) * ((float)id.x)/(float)sampleRate),
   0);
   
   InterlockedMax(MinMax[0],asuint(data.a) );
   InterlockedMin(MinMax[1],asuint(data.a) );
}


// Normalized UV Points to be passed in here!!!!!!!
float2 from = float2(0,0);
float2 to = float2(0,0);

[numthreads(1,1,1)]
void NormalizedSampler(uint3 id : SV_DispatchThreadID)
{
   // Access the texture!!!! 
   // Get Width and Height
   uint width = 0;
   uint height = 0;
   PassedInData.GetDimensions(width,height);

   // Sample across the line based on the sampleRate
   if(id.x < sampleRate)
   {
      float4 data = PassedInData.SampleLevel(_LinearClamp,from +  
      ((to - from) * ((float)id.x)/(float)sampleRate),
      0);
   
      InterlockedMax(MinMax[0],asuint(data.a) );
      InterlockedMin(MinMax[1],asuint(data.a) );
   }
   //MinMax[0] = width;//asuint(to.x);
   //MinMax[1] = height;//asuint(to.y);
}
